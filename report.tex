\documentclass[]{scrartcl}
\usepackage[french]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{pgf-umlsd}
\usepackage{tikz}

% \newthread[edge distance]{var}{thread name}
\renewcommand{\newthread}[3][0.2]{
	\newinst[#1]{#2}{#3}
	\stepcounter{threadnum}
	\node[below of=inst\theinstnum,node distance=0.8cm] (thread\thethreadnum) {};
	\tikzstyle{threadcolor\thethreadnum}=[fill=gray!30]
	\tikzstyle{instcolor#2}=[fill=gray!30]
}

\renewcommand{\mess}[3]{
\begin{messcall}{#1}{#2}{#3}\end{messcall}
}

\title{Protocole de sécurisation de gestion à distance d'un radar automatique de route}
\author{Pierre-Marie JUNGES, Florent NOSARI}

\begin{document}

\maketitle

\begin{abstract}

\end{abstract}

\section{Présentation du protocole}

\subsection{But}

Le but de ce protocole est de permettre la gestion à distance d'un radar automatique de route par les autorités compétentes en ayant la certitude que les informations soient authentiques (i.e. qu'elles proviennent bien des relevés fait par le radar/gestionnaire ), que seul le gestionnaire puisse accéder au données du radar, que seul le gestionnaire puisque contrôler le radar et que toutes les informations qui transitent entre les deux soient confidentielles (i.e. qu'une tierce personne ne puisse pas y avoir accès).
\\
\\
En résumé :
\\
\begin{itemize}
	\item Les informations qui transitent doivent être confidentielles et authentiques
	\item Seul le gestionnaire peut contrôler le radar et accéder au données du radar
\end{itemize}

\subsection{Contraintes}

Voici le contraintes que nous avons décidé de prendre en compte pour rendre le protocole plus proche des conditions réelles.
\begin{itemize}
	\item Les acteurs ne partagent pas de clé secrète avant l'initiation du protocole.
	\item Le gestionnaire ne connait pas nécessairement la clé publique du radar.
\end{itemize}


\subsection{Déroulement}

Le protocole est initié par le gestionnaire qui demande à un serveur d'authentification le droit de d'accéder au radar. Les échanges se font à l'aide de cryptographie à clé publique jusqu'à obtenir une clé secrète commune entre le gestionnaire et le radar. 
\\
\\
L'algorithme d'échange est décrit ci-dessous : 
\\
\\
Soient 
$G$ le gestionnaire avec $PKg$ sa clé publique et  $SKg$ sa clé privé
\\
$R$ le radar avec $PKr$ sa clé publique et  $SKr$ sa clé privé
\\
$S$ le serveur avec $PKs$ sa clé publique et  $SKs$ sa clé privé
\\
$K_{Session}$ la clé secrète partagé lors d'une session
\\
$N_{g}$, $N_{r}$ et $N_{c}$ des nonces
\\
$C$ une commande quelconque
\\
$R$ une réponse quelconque
\\
\\
Les connaissances initiales sont les suivantes :
\\
\\
$G : \{G, R, S, PKg, PKs, C\}$
\\
$R : \{R, S, PKr, PKs\}$
\\
$S : \{S, R, PKs, PKr\}$
\\
\\
Le gestionnaire initie le protocole en envoyant une demande de connexion au serveur avec l'objet de la demande signé.
\\
$G \rightarrow \{{R}_{inv(PKg)}.G\}_{PK_{s}} \longrightarrow S$
\\
\\
Si l'identité du gestionnaire et du radar sont vérifiée alors le serveur envoie les informations de connexion ($KSession$ étant générée à ce moment là et signé par le serveur) au gestionnaire.
\\
$G \longleftarrow \{\{K_{Session}\}_{inv(PKs)}.R.PK_{r}\}_{PK_{g}} \leftarrow S$
\\
\\
Une fois que le gestionnaire a reçu les informations de connexions, il envoie au radar la clé secrète $KSession$ signé par le serveur.
\\
$G \rightarrow \{G.\{KSession`\}_{inv(PKs)}\}_{PK_{r}} \longrightarrow R$
\\
\\
Le radar confirme la réception de la clé en envoyant $N_{g}$ au gestionnaire suivit $N_{r}$ pour vérifier l'authenticité de la commande qui va suivre.
\\
$G \longleftarrow \{G.N_{r}\}_{K_{Session}} \leftarrow R$
\\
\\
Le gestionnaire peut ainsi envoyer la commande et l'authentifier avec le nonce. 
\\
$G \rightarrow \{N_{r}.Commande\}_{K_{Session}} \longrightarrow R$
\\
\\
Le radar envoie par la suite la commande suivit du résultat de la commande.
\\
$G \longleftarrow \{Commande.Resultat\}_{K_{Session}} \leftarrow R$
\\
\\
\begin{figure}[h]
	\caption{Échanges effectués lors du déroulement du protocole}
	\centering
	\begin{sequencediagram}
		\newthread{G}{Gestionnaire}{}
		\newthread[4]{S}{Serveur}{}
		\newthread[4]{R}{Radar}{}
		
	
		\mess{G}{ $\{{R}_{inv(PKg)}.G\}_{PK_{s}}$ }{S}
					
		\mess{S}{ $\{\{K_{Session}\}_{inv(PKs)}.R.PK_{r}\}_{PK_{g}}$}{G}
		
		\mess{G}{ $\{G.\{KSession\}_{inv(PKs)}\}_{PK_{r}}$ }{R}
		
		\mess{R}{ $\{G.N_{r}\}_{K_{Session}}$ }{G}
		
		
		
		\begin{sdblock}{ Loop }{}
			\mess{G}{ $\{N_{r}.Commande\}_{K_{Session}}$ }{R}
			
			\mess{R}{ $\{Commande.Resultat\}_{K_{Session}}$ }{G}	
		\end{sdblock}
				
	\end{sequencediagram}
\end{figure}

\end{document}
